name: Deploy Containerized Lambda

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'The branch to deploy from'
        required: true
        default: 'develop'
        type: choice
        options:
          - main
          - develop

env:
  BRANCH_NAME: "main"
  GITHUB_SHA: ${{ github.sha }}

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.branch }}

    - name: set up python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'
        cache: 'pip'

    # configure aws credentials using oicd
    - name: configure aws credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-region: ${{ secrets.AWS_REGION_NAME }}
        role-to-assume: ${{ secrets.AWS_IAM_ROLE_ARN }}

    - name: set environment variables
      run: |
        echo "BRANCH_NAME=${{ github.event.inputs.branch }}" >> $GITHUB_ENV
        echo "SHORT_SHA=${GITHUB_SHA::8}" >> $GITHUB_ENV

    - name: check lambda function exists
      run: |
        aws lambda get-function --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} --region ${{ secrets.AWS_REGION_NAME }}

    - name: retrieve image tag and validate image
      id: validate_image
      run: |
        IMAGE_TAG=$(aws ssm get-parameter --name "/my-app/image-tag" --query "Parameter.Value" --output text || echo "")
        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

        if [[ -z "$IMAGE_TAG" ]]; then
          echo "... no image tag found in SSM. will create a new image"
          echo "has_image=false" >> $GITHUB_OUTPUT
        else
          echo "... checking for image with tag: $IMAGE_TAG"
          IMAGE_URI=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION_NAME }}.amazonaws.com/${{ secrets.ECR_REPOSITORY }}:${IMAGE_TAG}

          if aws ecr describe-images --repository-name ${{ secrets.ECR_REPOSITORY }} --image-ids imageTag=$IMAGE_TAG --region ${{ secrets.AWS_REGION_NAME }} > /dev/null 2>&1; then
            echo "... image found in ecr. will update lambda ..."
            echo "has_image=true" >> $GITHUB_OUTPUT
            echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_OUTPUT
          else
            echo "... image not found in ecr. will create a new image ..."
            echo "has_image=false" >> $GITHUB_OUTPUT
          fi
        fi

    - name: update lambda function with existing image
      if: ${{ steps.validate_image.outputs.has_image == 'true' }}
      run: |
        aws lambda update-function-code \
          --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
          --region ${{ secrets.AWS_REGION_NAME }} \
          --image-uri ${{ steps.validate_image.outputs.IMAGE_URI }}
        echo "...lambda function updated with existing image ..."

    - name: start codebuild for container build
      if: ${{ steps.validate_image.outputs.has_image == 'false' }}
      uses: aws-actions/aws-codebuild-run-build@v1
      id: codebuild
      with:
        project-name: ${{ secrets.CODEBUILD_PROJECT }}
        source-version-override: ${{ github.event.inputs.branch }}
        env-vars-for-codebuild: |
          [
            {
              "name": "GITHUB_REF",
              "value": "refs/heads/${{ github.event.inputs.branch }}"
            },
            {
              "name": "BRANCH_NAME",
              "value": "${{ env.BRANCH_NAME }}"
            },
            {
              "name": "ECR_REPOSITORY_NAME",
              "value": "${{ secrets.ECR_REPOSITORY }}"
            },
            {
              "name": "LAMBDA_FUNCTION_NAME",
              "value": "${{ secrets.LAMBDA_FUNCTION_NAME }}"
            }
          ]

    - name: update lambda function with a new image (after build)
      if: ${{ steps.validate_image.outputs.has_image == 'false' }}
      run: |
        LATEST_IMAGE_URI=$(aws ecr describe-images --repository-name ${{ secrets.ECR_REPOSITORY }} --query 'sort_by(imageDetails,&imagePushedAt)[-1].imagePushedAt' | xargs -I {} aws ecr describe-images --repository-name ${{ secrets.ECR_REPOSITORY }} --query 'imageDetails[?imagePushedAt==`{}`].imageUri' --output text)

        if [[ -z "$LATEST_IMAGE_URI" ]]; then
          echo "... failed to retrieve the new image uri ..."
          exit 1
        fi

        aws lambda update-function-code \
          --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
          --region ${{ secrets.AWS_REGION_NAME }} \
          --image-uri "$LATEST_IMAGE_URI"
        echo "... lambda function updated with newly built image ..."

    - name: verify lambda updates
      run: |
        CURRENT_IMAGE=$(aws lambda get-function \
          --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
          --region ${{ secrets.AWS_REGION_NAME }} \
          --query 'Code.ImageUri' \
          --output text)

        if [[ $CURRENT_IMAGE == *"dkr.ecr"* ]]; then
          echo "✅ lambda function successfully updated with new image"
        else
          echo "❌ lambda function update may have failed"
          exit 1
        fi

    - name: test lambda function
      if: github.event.inputs.branch == 'main'
      run: |
        aws lambda invoke \
          --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
          --region ${{ secrets.AWS_REGION_NAME }} \
          --payload '{"test": true}' \
          --cli-binary-format raw-in-base64-out \
          response.json

        cat response.json

    - name: update lambda environment variables (if needed)
      if: github.event.inputs.branch == 'main'
      run: |
        DEPLOY_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)

        aws lambda update-function-configuration \
          --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
          --region ${{ secrets.AWS_REGION_NAME }} \
          --environment "Variables={
            \"ENVIRONMENT\": \"production\",
            \"VERSION\": \"${{ github.sha }}\",
            \"DEPLOY_TIME\": \"$DEPLOY_TIME\"
          }"

    - name: cleanup
      if: always()
      run: |
        echo "=== Cleanup ==="
        rm -f response.json
        echo "✅ cleanup completed"
